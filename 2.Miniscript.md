# Guia para utilizar Miniscript en la linea de comandos

DISCLAIMER: Esta guia ha sido realizada con fines educativos. Siempre pruebe los comandos en redes de prueba y asegurese que va a poder desbloquear los BTC. Use bajo su propia responsabilidad.

## Introduccion

Tutorial para utilizar miniscript y descriptors para bloquear y gastar Bitcoin en la linea de comandos utilizando Bitcoin Core.

## Requisitos

Linux Debian 12, Bitcoin Core vs 30.0 en modo regtest

Compilador online miniscript: https://bitcoin.sipa.be/miniscript/

Importante leer todo el documento antes de continuar. 

Descriptors en multifirma, ver ejemplo en la documentación oficial:
https://github.com/bitcoin/bitcoin/blob/master/doc/multisig-tutorial.md

### Utilizando el compilador online

Miniscript es un lenguaje que describe algunos de los Scripts de Bitcoin de manera extructurada. Gracias al compilador online podemos de manera intuitiva obtener el miniscript con condiciones de gasto.

Para comprobar lo intuitivo que es Miniscript  vamos a ver algunos ejemplos.

Miniscript en el que Alice y Bob puedan gastar indistintamente. En el compilador introducimos:
```
or(pk(A),pk(B))
```
Obtenemos el resultado:
```
or_b(pk(A),s:pk(B))
```
Podemos hacer bloqueos de tiempo, en este caso un bloqueo relativo en numero de bloque. En el compilador online introducimos:
```
and(pk(A),older(10))
```
Obtenemos el resultado:
```
and_v(v:pk(A),older(10))
```
El operador thresh nos permite poner varias condiciones m y que solo n condiciones se tengan que cumplir para gastar, Alice, Bob y Carla pueden firmar en cualquier momento pero después de 10 bloques solo dos firmas son necesarias, ya que se cumplen 3 condiciones. Introducimos en el compilador online:
```
thresh(3,pk(A),pk(B),pk(C),older(10))
```
Obtenemos el resultado:
```
thresh(3,pk(A),s:pk(B),s:pk(C),sln:older(10))
```

### Vault

Uno de los casos mas interesantes de uso de miniscript es para proteger el BTC en caso de perdida de la clave o fallecimiento. Queremos que Alice pueda gastar siempre, pero Bob Carla o Diego puedan firmar con una multifirma dos de tres. Intuitivamente en el compilador online introducimos:
```
or(keyA, and(keyB, older(10)))
```
nos da el resultado
```
andor(pk(keyB),older(10),pk(keyA))
```
pero Alice es mas probable que gaste los BTC por lo que para que el compilador nos de un resultado optimo debemos introducir:
```
or(99@pk(keyA),and(pk(keyB),older(10)))
```
aqui le estamos diciendo al compilador que Alice tiene 99 mas probabilidades de gastar. El resultado es
```
or_d(pk(keyA),and_v(v:pkh(keyB),older(10)))
```
Luego utilizaremos este ultimo ¿Y donde está la multifirma? en keyB usaremos una multifirma 2 de 3. Nuestro miniscrpt será: or_d(pk(keyA),and_v(v:multi(2,keyB,keyC,keyD),older(10)))

### Descriptors y dirección

Recomiendo la lectura de la documentación oficial de [descriptors](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)

Ya hemos visto varios ejemplos de miniscript y ahora ¿como genero mi dirección para bloquear Bitcoin? pues utilizando los descriptors.

En el apartado de [Multifirma] (/1.Multifirma.md) creamos los wallets de Alice y Bob y extraiamos descriptors. Para obtener nuestro descriptor que contenga el miniscript, simplemente combinamos estos descriptors dentro de un wsh con el resultado del compilador, como se explica en la documentación oficial, ejemplos:

```
descA=$(bitcoin-cli -rpcwallet=Alice listdescriptors | jq -r '.descriptors | [.[] | select(.desc | startswith("wpkh") and contains("/0/*"))][0] | .desc'| grep -Po '(?<=\().*(?=\))')
```
El descriptor de los ejemplos anteriores aplicando el miniscript quedaría:
```
desc="wsh(or_b(pk($descA),s:pk($descB)))"
desc="wsh(and_v(v:pk($descA),older(10)))"
desc="wsh(thresh(3,pk($descAext),s:pk($descB),s:pk($descC),sln:older(10)))"
```

Si queremos utilizar el comando walletprocesspsbt necesitamos repetir el proceso con los descriptors internos, es decir los extraemos de Alice, Bob, etc y creamos el descriptor interno.

Añadimos el checksum del descriptor
```
extsum=$(bitcoin-cli getdescriptorinfo $desc | jq -r '.checksum')
```
Podemos derivar direcciones directamente del descriptor, pero en este tutorial voy a crear un wallet, de esta forma puedo usar luego listunspent.
```
bitcoin-cli -named createwallet wallet_name="descriptor" blank=true
bitcoin-cli  -rpcwallet="descriptor" importdescriptors "[{\"desc\": \"$descsum\",\"timestamp\": \"now\",\"active\": true,\"watching-only\": false,\"internal\": false,\"range\": [0,999]}]"
bitcoin-cli -rpcwallet="descriptor" getnewaddress
```
Ya tengo una dirección a la que puedo enviar fondos.

### Crear transacción

Para crear una transacción, primero necesito obtener los datos de los UTXOS, el id de la transacción (txid) y el numero de salida (vout), como he creado un wallet, puedo usar listunspent:
```
txid=$(bitcoin-cli -rpcwallet=descriptor listunspent | jq -r '.[0] | .txid')
vout=$(bitcoin-cli -rpcwallet=descriptor listunspent | jq -r '.[0] | .vout')
```
Para crear nuestra transacción tengo que analizar ¿que tipo de transacción es?. En la transacción multifirma usabamos createpsbt o walletfundedpsbt. Una transacción psbt es una transacción de Bitcoin parcialmente firmada, pero en uno de los ejemplos anteriores la transacción solo tenia un bloqueo de tiempo, no es una transacción psbt. En este caso solo tengo que crear una transacción con un bloqueo de tiempo, con esto le estoy diciendo todo lo necesario al comando createwallet para que cree la transacción:
```
rawtxhex=$(bitcoin-cli -named createrawtransaction inputs="[{\"txid\": \"$txid\",\"vout\":0,\"sequence\":10}]" outputs="[{\"$direccionAlice\":49.998}]")
```
Para los otros ejemplos aunque solo necesite una firma, estoy usando una PSBT, es una transacción parcialmente firmada, entonces creo la transacción con createpsbt, ¡¡¡ojo con los fees!!!
```
psbt=$(bitcoin-cli -named createpsbt inputs="[{\"txid\": \"$txid\",\"vout\":0}]" outputs="[{\"$direccion\":49.998}]")
```
Si la condición de gasto que estoy usando tiene un bloqueo de tiempo relativo, añado la condición en el campo sequence, si tiene un bloqueo absoluto, añado locktime.Nota que esto solo es necesario si el o los firmantes tienen un bloqueo de tiempo. Ejemplo de bloqueo de tiempo relativo con 10 bloques:
```
psbt=$(bitcoin-cli -named createpsbt inputs="[{\"txid\": \"$txid\",\"vout\":0,\"sequence\":10}]" outputs="[{\"$direccion\":49.998}]")
```
Mi transacción no tiene todavia las condiciones de gasto, tengo que actualizar (update) con el descriptor que he creado, el descriptor con el checksum.
```
psbtupdate=$(bitcoin-cli utxoupdatepsbt $psbt "[{\"desc\": \"$descsum\"}]")
```
En lugar de createpsbt y utxoupdatepsbt se puede usar walletfundedpsbt si he importado los descritors internos al wallet. Si hay un cambio walletfundedpsbt enviará el cambio a una dirección con las mismas condiciones de bloqueo, esto no tiene mucho sentido en algunos casos, por ejemplo si Alice perdió sus claves no vamos a bloquear el cambio en una dirección que tenga a Alice, por eso estoy utilizando createpsbt y utxoupdatepsbt.

### Firmar mi transacción

Si tenemos una transacción creada con createrawtransaction, firmamos con nuestro wallet, si tenemos una transacción psbt sencilla podemos firmar con walletprocesspsbt y combinar las firmas tal y como se hizo con la multifirma. En algunos casos con un descriptor complicado el wallet no sabe firmar la transacción. Entonces lo que hacemos es crear un nuevo wallet y en el descritor con el miniscript introducimos las claves públicas de los wallets y la combinaremos con clave privada de nuestro wallet, veamos un ejemplo de nuestro wallet creado con el miniscript thresh:

Alice crea un wallet con sus descriptors privados, los une a los descriptors publicos de los demas participantes:
```
descAextpriv=$(bitcoin-cli -rpcwallet=Alice listdescriptors true | jq -r '.descriptors | [.[] | select(.desc | startswith("wpkh") and contains("/0/*"))][0] | .desc'| grep -Po '(?<=\().*(?=\))')
descextA="wsh(thresh(3,pk($descAextpriv),s:pk($descBext),s:pk($descCext),sln:older(10)))"
extsumA=$(bitcoin-cli getdescriptorinfo $descextA | jq -r '.checksum')
extdescsumA=$descextA#$extsumA
bitcoin-cli -named createwallet wallet_name="descriptorA" blank=true
bitcoin-cli  -rpcwallet="descriptorA" importdescriptors "[{\"desc\": \"$extdescsumA\",\"timestamp\": \"now\",\"active\": true,\"watching-only\": false,\"internal\": false,\"range\": [0,999]}]"
```
Ya tenemos un wallet descriptorA que puede firmar la parte de la transacción de Alice. Nota que cuando usamos createwallet tiene el argumento blank=true pero no estoy indicando que no tenga private keys (disable_private_keys) como si hacía con los otros wallets, este wallet si tiene private keys, las de Alice en este caso.

Tambien fijate cuando importo los descriptors al wallet descriptorA, indico watching-only: false.

Igualmente Bob crea un wallet con sus descriptors privados y los une a los descriptors publicos de los demas participantes creando un wallet descriptorB.
A partir de aqui el proceso es igual que con la multifirma:
```
psbtA=$(bitcoin-cli -rpcwallet="descriptorA" walletprocesspsbt $psbtupdate | jq -r '.psbt')
psbtB=$(bitcoin-cli -rpcwallet="descriptorB" walletprocesspsbt $psbtupdate | jq -r '.psbt')
combinedpsbt=$(bitcoin-cli combinepsbt "[\"$psbtA\", \"$psbtB\"]")
finalizedpsbt=$(bitcoin-cli finalizepsbt $combinedpsbt | jq -r '.hex')
bitcoin-cli sendrawtransaction $finalizedpsbt
```
Encontraras en el directorio ejemplos varios bash scripts.

### Miniscript y taproot

Para utilizar miniscript en taproot, volvemos a la documentación de [Miniscript](https://bitcoin.sipa.be/miniscript/) hay algunas funciones que puedes usar con tapscript y otras que no. También en la documentación de los [descriptors](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md) encontramos lo siguiente: tr(c6..9ee5,{pk(ff..56),pk(e44..d13)}) describe un P2TR output con x-only pubkey, y dos script paths.
Como sabeis el standard para taproot es que hay dos formas de gastar, una el "key-path", que solo aparece una firma (pueden ser varias con key agregation que no vamos a ver en este tutorial) y el segundo es el script path, dentro de este podemos tener varios caminos (leaves).

### Crear el Miniscript

Voy a crear un wallet en el que Alice podrá gastar siempre con el key-path, Bob, Carla y Diego pueden firmar dos de 3 y Diego puede firmar solo después de 10 bloques.
tr($xpubkA,{multi_a(2,$xpubkB,$xpubkC,$xpubkD),and_v(v:pk($xpubkD),older(10))})

### Descriptors
Vamos a obtener entonces las coordenadas x de los wallets para importar el descriptor resultante.
Repito el siguiente proceso para los wallets de Alice, Bob, Carla y Diego:
```
dirAlice=$(bitcoin-cli -rpcwallet=Alice getnewaddress)
xpubkA=$(bitcoin-cli -rpcwallet=Alice getaddressinfo $dirAlice | jq -r '.pubkey')
xpubkA=${xpubkA:2}
```
Nota que con pubkey estoy obteniendo la coordenada de x de la llave publica, pero con 02 o 03 al principio que indica si es positiva o negativa, pero en la documentación de taproot me indican que solo necesito la coordenada x, quito los dos primeros caracteres.

Obtengo el checksum:
```
desc="tr($xpubkA,{multi_a(2,$xpubkB,$xpubkC,$xpubkD),and_v(v:pk($xpubkD),older(10))})"
descsum=$(bitcoin-cli getdescriptorinfo $desc | jq -r  '.descriptor')
dirdesc=$(bitcoin-cli deriveaddresses $descsum | jq -r '.[0]')
```
Cree el descriptor y generé una nueva dirección. Para poder utilizar listunspent es conveniente crear un wallet:
```
bitcoin-cli -named createwallet wallet_name="tr" disable_private_keys=true blank=true
bitcoin-cli -rpcwallet="tr" importdescriptors "[{\"desc\": \"$descsum\",\"timestamp\": \"now\",\"active\": false,\"watching-only\": true,\"internal\": false}]"
```
Nota que no he puesto el rango en este wallet, ya que es un wallet con una sola coordenada x obtenida de una dirección derivada, no puedo derivar varias direcciones con este wallet.

Ahora ya puedo enviar Bitcoin a esta dirección, este wallet me dará los utxos que puedo gastar.

### Crear transacción y firmar

Tengo tres opciones para gastar, vamos a probar las 3. Para mostrarlo voy a reutilizar las direcciones ya que esta guia es con fines educativos.
Primero gasta solo Alice:
```
psbt=$(bitcoin-cli -named createpsbt inputs="[{\"txid\": \"$identtx\",\"vout\":0}]" outputs="[{\"$direccion\":49.998}]")
psbtupdate=$(bitcoin-cli utxoupdatepsbt $psbt "[{\"desc\": \"$descsum\"}]")
psbtA=$(bitcoin-cli -rpcwallet="Alice" walletprocesspsbt $psbtupdate | jq -r '.psbt')
finalizedpsbt=$(bitcoin-cli finalizepsbt $psbtA | jq -r '.hex')
bitcoin-cli sendrawtransaction $finalizedpsbt
```
Nota que es una transacción psbt aunque solo Alice firme y no tiene bloqueo de tiempo.

Ahora vamos a crear la transacción que van a firmar Bob y Carla
```
identtx=$(bitcoin-cli -rpcwallet=tr listunspent | jq -r '.[0] | .txid')
psbt=$(bitcoin-cli -named createpsbt inputs="[{\"txid\": \"$identtx\",\"vout\":0}]" outputs="[{\"$direccion\":49.998}]")
psbtupdate=$(bitcoin-cli utxoupdatepsbt $psbt "[{\"desc\": \"$descsum\"}]")
bitcoin-cli decodepsbt $psbtupdate
psbtB=$(bitcoin-cli -rpcwallet="Bob" walletprocesspsbt $psbtupdate | jq -r '.psbt')
psbtC=$(bitcoin-cli -rpcwallet="Carla" walletprocesspsbt $psbtupdate | jq -r '.psbt')
combinedpsbt=$(bitcoin-cli combinepsbt "[\"$psbtB\", \"$psbtC\"]")
finalizedpsbt=$(bitcoin-cli finalizepsbt $combinedpsbt | jq -r '.hex')
bitcoin-cli sendrawtransaction $finalizedpsbt
```
Como ves es una transacción multifirma normal.

Por ultimo va a firmar Diego solo, tiene un bloqueo de tiempo:
```
psbt=$(bitcoin-cli -named createpsbt inputs="[{\"txid\": \"$identtx\",\"vout\":0,\"sequence\":10}]" outputs="[{\"$dirDiego\":9.998}]")
psbtupdate=$(bitcoin-cli utxoupdatepsbt $psbt "[{\"desc\": \"$descsum\"}]")
psbtD=$(bitcoin-cli -rpcwallet="Diego" walletprocesspsbt $psbtupdate | jq -r '.psbt')
finalizedpsbt=$(bitcoin-cli finalizepsbt $psbtD | jq -r '.hex')
bitcoin-cli sendrawtransaction $finalizedpsbt
```
Si envias la transacción y no han pasado 10 bloques nos dará un error, despues de minar los bloques podremos enviar la transacción.

Si llegaste hasta aquí te propongo que utilices el comando decoderawtransaction para ver las 3 transacciones, ¿que diferencias ves en el campo txinwitness?